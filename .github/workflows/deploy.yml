name: Deploy (Reusable)

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (dev or production)'
        required: true
        type: string
      version:
        description: 'Version to deploy'
        required: false
        type: string
        default: ''
      log_retention_days:
        description: 'Days to retain deployment logs'
        required: false
        type: number
        default: 14
      BASE_URI:
        description: 'Base URI for the deployment'
        required: true
        type: string
    secrets:
      SSH_PRIVATE_KEY:
        required: true
      SERVER_HOST:
        required: true
      MIRO_CLIENT_ID_B64:
        required: true
      MIRO_CLIENT_SECRET_B64:
        required: true

env:
  CI: "true"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Get version and image tag
        id: version
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            VERSION="${{ github.ref_name }}"
            IMAGE_TAG="${VERSION}"
          elif [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
            IMAGE_TAG="${VERSION}"
          else
            # For dev deployments from main branch
            VERSION="$(echo ${{ github.sha }} | cut -c1-7)"
            IMAGE_TAG="${{ inputs.environment }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Deploying version: ${VERSION} (image tag: ${IMAGE_TAG}) to ${{ inputs.environment }}"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

          # Configure SSH keepalives for long-running commands
          cat >> ~/.ssh/config << 'EOF'
          Host *
            ServerAliveInterval 60
            ServerAliveCountMax 10
          EOF

          # Start SSH agent and add key
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_rsa

          # Test connection
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"

      - name: Generate .env file
        run: |
          cat > .env << EOF
          # ${{ inputs.environment }} Environment - Generated by GitHub Actions
          NODE_ENV=production
          PORT=3000
          BASE_URI=${{ inputs.BASE_URI }}
          MIRO_CLIENT_ID_B64=${{ secrets.MIRO_CLIENT_ID_B64 }}
          MIRO_CLIENT_SECRET_B64=${{ secrets.MIRO_CLIENT_SECRET_B64 }}
          # Tokens are generated via /oauth/authorize and stored in /data/tokens.json
          EOF

      - name: Checkout deployment files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-compose.yml
          path: miro-mcp

      - name: Update docker-compose to use registry image
        run: |
          cd miro-mcp
          # Replace build context with image from registry
          sed -i.bak 's|build: \.|image: ghcr.io/${{ github.repository }}:${{ steps.version.outputs.image_tag }}|' docker-compose.yml
          cat docker-compose.yml

      - name: Upload .env and docker-compose to server
        run: |
          ssh root@${{ secrets.SERVER_HOST }} "mkdir -p /opt/miro-mcp"
          scp .env root@${{ secrets.SERVER_HOST }}:/opt/miro-mcp/
          scp miro-mcp/docker-compose.yml root@${{ secrets.SERVER_HOST }}:/opt/miro-mcp/

      - name: Login to registry on server and pull image
        run: |
          ssh root@${{ secrets.SERVER_HOST }} bash << REMOTE_EOF
          set -e

          # Login to GitHub Container Registry
          echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # Pull the image
          docker pull ghcr.io/${{ github.repository }}:${{ steps.version.outputs.image_tag }}

          # Tag as latest for docker-compose
          docker tag ghcr.io/${{ github.repository }}:${{ steps.version.outputs.image_tag }} \
                     ghcr.io/${{ github.repository }}:latest
          REMOTE_EOF

      - name: Deploy with docker-compose
        run: |
          ssh root@${{ secrets.SERVER_HOST }} bash << 'REMOTE_EOF'
          set -e
          cd /opt/miro-mcp

          # Ensure data directory exists
          mkdir -p data

          # Ensure ingress network exists
          docker network create ingress 2>/dev/null || true

          # Stop old containers
          docker compose down 2>/dev/null || true

          # Start with registry image
          docker compose up -d

          # Wait for container to start
          sleep 10

          echo "Container status:"
          docker compose ps
          REMOTE_EOF

      - name: Save deployment log
        if: always()
        run: echo "Deployment completed for ${{ inputs.environment }}" > deploy.log

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-${{ inputs.environment }}
          path: deploy.log
          retention-days: ${{ inputs.log_retention_days }}

      - name: Verify deployment
        run: |
          sleep 5
          if ! ssh root@${{ secrets.SERVER_HOST }} "docker ps | grep -q miro-mcp"; then
            echo "Error: miro-mcp container not running!"
            ssh root@${{ secrets.SERVER_HOST }} "cd /opt/miro-mcp && docker compose logs"
            exit 1
          fi
          echo "âœ… Container is running"

      - name: Deployment summary
        run: |
          echo "============================================"
          echo "DEPLOYMENT SUCCESSFUL"
          echo "Environment: ${{ inputs.environment }}"
          echo "Version: ${{ steps.version.outputs.version }}"
          echo "Image: ghcr.io/${{ github.repository }}:${{ steps.version.outputs.image_tag }}"
          echo "Server: ${{ secrets.SERVER_HOST }}"
          echo "============================================"
